{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"page1/","text":"Time Managment \u0420\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0430\u0439\u0442\u0435 \u043f\u0440\u043e\u0441\u0442\u0443\u044e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443-\u0442\u0430\u0439\u043c-\u043c\u0435\u043d\u0435\u0434\u0436\u0435\u0440, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043f\u043e\u043c\u043e\u0436\u0435\u0442 \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0432\u0430\u0448\u0438\u043c \u0432\u0440\u0435\u043c\u0435\u043d\u0435\u043c \u0438 \u0437\u0430\u0434\u0430\u0447\u0430\u043c\u0438. \u041f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0442\u044c \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0442\u044c \u0437\u0430\u0434\u0430\u0447\u0438 \u0441 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435\u043c, \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0442\u044c \u0438\u043c \u0441\u0440\u043e\u043a\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0438 \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u044b, \u0430 \u0442\u0430\u043a\u0436\u0435 \u043e\u0442\u0441\u043b\u0435\u0436\u0438\u0432\u0430\u0442\u044c \u0437\u0430\u0442\u0440\u0430\u0447\u0435\u043d\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f \u043d\u0430 \u043a\u0430\u0436\u0434\u0443\u044e \u0437\u0430\u0434\u0430\u0447\u0443. \u0414\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u043c\u043e\u0433\u0443\u0442 \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u0432 \u0441\u0435\u0431\u044f \u0443\u0432\u0435\u0434\u043e\u043c\u043b\u0435\u043d\u0438\u044f \u043e \u043f\u0440\u0438\u0431\u043b\u0438\u0436\u0435\u043d\u0438\u0438 \u043a \u0434\u0435\u0434\u043b\u0430\u0439\u043d\u0430\u043c, \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0435\u0436\u0435\u0434\u043d\u0435\u0432\u043d\u043e\u0433\u043e \u0440\u0430\u0441\u043f\u0438\u0441\u0430\u043d\u0438\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0438 \u0430\u043d\u0430\u043b\u0438\u0437 \u0432\u0440\u0435\u043c\u0435\u043d\u0438, \u0437\u0430\u0442\u0440\u0430\u0447\u0435\u043d\u043d\u043e\u0433\u043e \u043d\u0430 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0435 \u0437\u0430\u0434\u0430\u0447\u0438.","title":"Time Managment"},{"location":"page1/#time-managment","text":"\u0420\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0430\u0439\u0442\u0435 \u043f\u0440\u043e\u0441\u0442\u0443\u044e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443-\u0442\u0430\u0439\u043c-\u043c\u0435\u043d\u0435\u0434\u0436\u0435\u0440, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u043f\u043e\u043c\u043e\u0436\u0435\u0442 \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u0442\u044c \u0432\u0430\u0448\u0438\u043c \u0432\u0440\u0435\u043c\u0435\u043d\u0435\u043c \u0438 \u0437\u0430\u0434\u0430\u0447\u0430\u043c\u0438. \u041f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0442\u044c \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0442\u044c \u0437\u0430\u0434\u0430\u0447\u0438 \u0441 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435\u043c, \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0442\u044c \u0438\u043c \u0441\u0440\u043e\u043a\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0438 \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u044b, \u0430 \u0442\u0430\u043a\u0436\u0435 \u043e\u0442\u0441\u043b\u0435\u0436\u0438\u0432\u0430\u0442\u044c \u0437\u0430\u0442\u0440\u0430\u0447\u0435\u043d\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f \u043d\u0430 \u043a\u0430\u0436\u0434\u0443\u044e \u0437\u0430\u0434\u0430\u0447\u0443. \u0414\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u043c\u043e\u0433\u0443\u0442 \u0432\u043a\u043b\u044e\u0447\u0430\u0442\u044c \u0432 \u0441\u0435\u0431\u044f \u0443\u0432\u0435\u0434\u043e\u043c\u043b\u0435\u043d\u0438\u044f \u043e \u043f\u0440\u0438\u0431\u043b\u0438\u0436\u0435\u043d\u0438\u0438 \u043a \u0434\u0435\u0434\u043b\u0430\u0439\u043d\u0430\u043c, \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u0435\u0436\u0435\u0434\u043d\u0435\u0432\u043d\u043e\u0433\u043e \u0440\u0430\u0441\u043f\u0438\u0441\u0430\u043d\u0438\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0438 \u0430\u043d\u0430\u043b\u0438\u0437 \u0432\u0440\u0435\u043c\u0435\u043d\u0438, \u0437\u0430\u0442\u0440\u0430\u0447\u0435\u043d\u043d\u043e\u0433\u043e \u043d\u0430 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0435 \u0437\u0430\u0434\u0430\u0447\u0438.","title":"Time Managment"},{"location":"page2/","text":"models.py class User(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) username: str = Field(index=True) hashed_password: str password: Optional[str] = Field(default=None, exclude=True) is_active: bool = Field(default=True) tasks: List[\"Task\"] = Relationship(back_populates=\"owner\") class TaskCategory(SQLModel, table=True): task_id: int = Field(foreign_key=\"task.id\", primary_key=True) category_id: int = Field(foreign_key=\"category.id\", primary_key=True) additional_info: str task: \"Task\" = Relationship(back_populates=\"task_categories\") category: \"Category\" = Relationship(back_populates=\"category_tasks\") class Task(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) title: str description: str deadline: Optional[date] = None priority: int = Field(default=1) user_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") owner: User = Relationship(back_populates=\"tasks\") task_categories: List[TaskCategory] = Relationship(back_populates=\"task\") time_logs: List[\"TimeLog\"] = Relationship(back_populates=\"task\") class Category(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str category_tasks: List[TaskCategory] = Relationship(back_populates=\"category\") class TimeLog(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) task_id: int = Field(foreign_key=\"task.id\") time_spent_minutes: int date_logged: date task: Task = Relationship(back_populates=\"time_logs\")","title":"models.py"},{"location":"page2/#modelspy","text":"class User(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) username: str = Field(index=True) hashed_password: str password: Optional[str] = Field(default=None, exclude=True) is_active: bool = Field(default=True) tasks: List[\"Task\"] = Relationship(back_populates=\"owner\") class TaskCategory(SQLModel, table=True): task_id: int = Field(foreign_key=\"task.id\", primary_key=True) category_id: int = Field(foreign_key=\"category.id\", primary_key=True) additional_info: str task: \"Task\" = Relationship(back_populates=\"task_categories\") category: \"Category\" = Relationship(back_populates=\"category_tasks\") class Task(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) title: str description: str deadline: Optional[date] = None priority: int = Field(default=1) user_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") owner: User = Relationship(back_populates=\"tasks\") task_categories: List[TaskCategory] = Relationship(back_populates=\"task\") time_logs: List[\"TimeLog\"] = Relationship(back_populates=\"task\") class Category(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str category_tasks: List[TaskCategory] = Relationship(back_populates=\"category\") class TimeLog(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) task_id: int = Field(foreign_key=\"task.id\") time_spent_minutes: int date_logged: date task: Task = Relationship(back_populates=\"time_logs\")","title":"models.py"},{"location":"page3/","text":"main.py app = FastAPI( title = \"Time Managment\" ) @app.on_event(\"startup\") def on_startup(): init_db() with Session(engine) as session: create_data(session) def create_data(session: Session): session.commit() def main(): with Session(engine) as session: create_data(session) app.include_router(user_router) app.include_router(tasks_router) app.include_router(categ_router) app.include_router(timelogs_router) app.include_router(taskscateg_router) app.include_router(add_router) pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\") def hash_password(password: str) -> str: return pwd_context.hash(password) def verify_password(plain_password: str, hashed_password: str) -> bool: return pwd_context.verify(plain_password, hashed_password) SECRET_KEY = secrets.token_urlsafe(32) ALGORITHM = \"HS256\" def create_access_token(data: dict, expires_delta: timedelta = None) -> str: to_encode = data.copy() if expires_delta: expire = datetime.utcnow() + expires_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to_encode.update({\"exp\": expire}) encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM) return encoded_jwt @app.post(\"/usersReg\") def create_user(username: str, password: str, session: Session = Depends(get_session)): hashed_password = hash_password(password) user = User(username=username, hashed_password=hashed_password) session.add(user) session.commit() session.refresh(user) return user @app.post(\"/token\") def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends(), session: Session = Depends(get_session)): user = authenticate_user(form_data.username, form_data.password, session) if not user: raise HTTPException(status_code=400, detail=\"Incorrect username or password\") access_token_expires = timedelta(minutes=30) access_token = create_access_token( data={\"sub\": user.username}, expires_delta=access_token_expires ) return {\"access_token\": access_token, \"token_type\": \"bearer\"} def authenticate_user(username: str, password: str, session: Session): user = session.query(User).filter(User.username == username).first() if not user: return False if not verify_password(password, user.hashed_password): return False return user oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") def verify_token(token: str, credentials_exception): try: payload = jwt.decode(token, SECRET_KEY, algorithms=[\"HS256\"]) username: str = payload.get(\"sub\") if username is None: raise credentials_exception return username except JWTError: raise credentials_exception def get_current_active_user(token: str = Depends(oauth2_scheme), session: Session = Depends(get_session)): credentials_exception = HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) username = verify_token(token, credentials_exception) user = session.query(User).filter(User.username == username).first() if user is None: raise credentials_exception if not user.is_active: raise HTTPException(status_code=400, detail=\"Inactive user\") return user @app.get(\"/users/me\") def read_current_user(current_user: User = Depends(get_current_active_user)): return current_user @app.post(\"/users/change-password\") def change_password(password_change: PasswordChange, current_user: User = Depends(get_current_active_user), session: Session = Depends(get_session)): try: user = session.query(User).filter(User.id == current_user.id).first() if not user: raise HTTPException(status_code=404, detail=\"User not found\") if not verify_password(password_change.old_password, user.hashed_password): raise HTTPException(status_code=400, detail=\"Incorrect old password\") user.hashed_password = hash_password(password_change.new_password) session.add(user) session.commit() return {\"msg\": \"Password changed successfully\"} except SQLAlchemyError as e: session.rollback() raise HTTPException(status_code=500, detail=\"Internal Server Error\")","title":"main.py"},{"location":"page3/#mainpy","text":"app = FastAPI( title = \"Time Managment\" ) @app.on_event(\"startup\") def on_startup(): init_db() with Session(engine) as session: create_data(session) def create_data(session: Session): session.commit() def main(): with Session(engine) as session: create_data(session) app.include_router(user_router) app.include_router(tasks_router) app.include_router(categ_router) app.include_router(timelogs_router) app.include_router(taskscateg_router) app.include_router(add_router) pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\") def hash_password(password: str) -> str: return pwd_context.hash(password) def verify_password(plain_password: str, hashed_password: str) -> bool: return pwd_context.verify(plain_password, hashed_password) SECRET_KEY = secrets.token_urlsafe(32) ALGORITHM = \"HS256\" def create_access_token(data: dict, expires_delta: timedelta = None) -> str: to_encode = data.copy() if expires_delta: expire = datetime.utcnow() + expires_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to_encode.update({\"exp\": expire}) encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM) return encoded_jwt @app.post(\"/usersReg\") def create_user(username: str, password: str, session: Session = Depends(get_session)): hashed_password = hash_password(password) user = User(username=username, hashed_password=hashed_password) session.add(user) session.commit() session.refresh(user) return user @app.post(\"/token\") def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends(), session: Session = Depends(get_session)): user = authenticate_user(form_data.username, form_data.password, session) if not user: raise HTTPException(status_code=400, detail=\"Incorrect username or password\") access_token_expires = timedelta(minutes=30) access_token = create_access_token( data={\"sub\": user.username}, expires_delta=access_token_expires ) return {\"access_token\": access_token, \"token_type\": \"bearer\"} def authenticate_user(username: str, password: str, session: Session): user = session.query(User).filter(User.username == username).first() if not user: return False if not verify_password(password, user.hashed_password): return False return user oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") def verify_token(token: str, credentials_exception): try: payload = jwt.decode(token, SECRET_KEY, algorithms=[\"HS256\"]) username: str = payload.get(\"sub\") if username is None: raise credentials_exception return username except JWTError: raise credentials_exception def get_current_active_user(token: str = Depends(oauth2_scheme), session: Session = Depends(get_session)): credentials_exception = HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) username = verify_token(token, credentials_exception) user = session.query(User).filter(User.username == username).first() if user is None: raise credentials_exception if not user.is_active: raise HTTPException(status_code=400, detail=\"Inactive user\") return user @app.get(\"/users/me\") def read_current_user(current_user: User = Depends(get_current_active_user)): return current_user @app.post(\"/users/change-password\") def change_password(password_change: PasswordChange, current_user: User = Depends(get_current_active_user), session: Session = Depends(get_session)): try: user = session.query(User).filter(User.id == current_user.id).first() if not user: raise HTTPException(status_code=404, detail=\"User not found\") if not verify_password(password_change.old_password, user.hashed_password): raise HTTPException(status_code=400, detail=\"Incorrect old password\") user.hashed_password = hash_password(password_change.new_password) session.add(user) session.commit() return {\"msg\": \"Password changed successfully\"} except SQLAlchemyError as e: session.rollback() raise HTTPException(status_code=500, detail=\"Internal Server Error\")","title":"main.py"},{"location":"page4/","text":"app/Routes.py categories router = APIRouter() @router.get(\"/categories/{category_id}/tasks\", response_model=List[Task]) def read_tasks_by_category(category_id: int, session: Session = Depends(get_session)): category = session.get(Category, category_id) if not category: raise HTTPException(status_code=404, detail=\"Category not found\") tasks = session.query(Task).join(TaskCategory).filter(TaskCategory.category_id == category_id).all() return tasks @router.get(\"/tasks/{task_id}/categories\", response_model=List[Category]) def read_categories_by_task(task_id: int, session: Session = Depends(get_session)): task = session.get(Task, task_id) if not task: raise HTTPException(status_code=404, detail=\"Task not found\") categories = session.query(Category).join(TaskCategory).filter(TaskCategory.task_id == task_id).all() return categories @router.get(\"/usersall/\", response_model=List[UserWithTaskNames]) def read_users_with_tasks(session: Session = Depends(get_session)): statement = select(User).options(joinedload(User.tasks)).distinct() result = session.execute(statement) users = result.scalars().unique().all() users_with_task_names = [] for user in users: user_data = { \"id\": user.id, \"username\": user.username, \"tasks\": [{\"title\": task.title} for task in user.tasks] } users_with_task_names.append(UserWithTaskNames(**user_data)) return users_with_task_names users router = APIRouter() @router.get(\"/users/\", response_model=List[UserResponse]) def read_users(session: Session = Depends(get_session)): users = session.execute(select(User)).scalars().all() return [UserResponse(id=user.id, username=user.username) for user in users] @router.get(\"/users/{user_id}\", response_model=User) def read_user(user_id: int, session: Session = Depends(get_session)): user = session.get(User, user_id) if user is None: raise HTTPException(status_code=404, detail=\"User not found\") return user @router.post(\"/users/\", response_model=int) def create_user(user: UserCreate, session: Session = Depends(get_session)): db_user = User(username=user.username) session.add(db_user) session.commit() session.refresh(db_user) return db_user.id @router.put(\"/users/{user_id}\") def update_user(user_id: int, user_update: UserUpdate, session: Session = Depends(get_session)): user = session.get(User, user_id) if not user: raise HTTPException(status_code=404, detail=\"User not found\") if user_update.username is not None: user.username = user_update.username session.commit() return {\"message\": \"User updated successfully\"} @router.delete(\"/users/{user_id}\") def delete_user(user_id: int, session: Session = Depends(get_session)): user = session.get(User, user_id) if not user: raise HTTPException(status_code=404, detail=\"User not found\") session.delete(user) session.commit() return {\"message\": \"User deleted successfully\"} tasks router = APIRouter() @router.post(\"/tasks/\", response_model=Task) def create_task(task: Task, session: Session = Depends(get_session)): db_task = Task.from_orm(task) session.add(db_task) session.commit() session.refresh(db_task) return db_task @router.get(\"/tasks/\", response_model=List[Task]) def read_tasks(session: Session = Depends(get_session)): tasks = session.execute(select(Task)).scalars().all() return tasks @router.get(\"/tasks/{task_id}\", response_model=Task) def read_task(task_id: int, session: Session = Depends(get_session)): task = session.get(Task, task_id) if not task: raise HTTPException(status_code=404, detail=\"Task not found\") return task @router.put(\"/tasks/{task_id}\", response_model=Task) def update_task(task_id: int, task_data: Task, session: Session = Depends(get_session)): db_task = session.get(Task, task_id) if not db_task: raise HTTPException(status_code=404, detail=\"Task not found\") update_data = task_data.dict(exclude_unset=True) for key, value in update_data.items(): setattr(db_task, key, value) session.add(db_task) session.commit() session.refresh(db_task) return db_task @router.delete(\"/tasks/{task_id}\", response_model=dict) def delete_task(task_id: int, session: Session = Depends(get_session)): task = session.get(Task, task_id) if not task: raise HTTPException(status_code=404, detail=\"Task not found\") timelogs = session.query(TimeLog).filter(TimeLog.task_id == task_id).all() for timelog in timelogs: session.delete(timelog) for task_category in task.task_categories: session.delete(task_category) session.delete(task) session.commit() return {\"ok\": True} tasksCategories router = APIRouter() @router.post(\"/task_categories/\") def create_task_category(task_category_data: TaskCategoryCreate, session: Session = Depends(get_session)): task_category = TaskCategory(**task_category_data.dict()) session.add(task_category) session.commit() session.refresh(task_category) return task_category @router.get(\"/task_categories/\", response_model=List[TaskCategory]) def read_task_categories(session: Session = Depends(get_session)): task_categories = session.query(TaskCategory).all() return task_categories @router.get(\"/task_categories/{id}\", response_model=List[TaskCategory]) def read_task_category(task_id: int, category_id: int, session: Session = Depends(get_session)): statement = select(TaskCategory).where(TaskCategory.task_id == task_id, TaskCategory.category_id == category_id) results = session.exec(statement).all() if not results: raise HTTPException(status_code=404, detail=\"TaskCategory not found\") return results @router.put(\"/task_categories/{task_id}/{category_id}\", response_model=TaskCategoryUpdate) def update_task_category(task_id: int, category_id: int, task_category_update: TaskCategory, session: Session = Depends(get_session)): db_task_category = session.get(TaskCategory, {'task_id': task_id, 'category_id': category_id}) if not db_task_category: raise HTTPException(status_code=404, detail=\"TaskCategory not found\") db_task_category.additional_info = task_category_update.additional_info session.commit() return db_task_category timelogs router = APIRouter() @router.post(\"/timelogs/\", response_model=TimeLog) def create_timelog(timelog: TimeLogCreate, session: Session = Depends(get_session)): task = session.get(Task, timelog.task_id) if not task: raise HTTPException(status_code=404, detail=f\"Task with id {timelog.task_id} not found\") db_timelog = TimeLog(**timelog.dict()) session.add(db_timelog) try: session.commit() except Exception as e: session.rollback() raise HTTPException(status_code=400, detail=str(e)) session.refresh(db_timelog) return db_timelog @router.get(\"/timelogs/{timelog_id}\", response_model=TimeLog) def read_timelog(timelog_id: int, session: Session = Depends(get_session)): timelog = session.query(TimeLog).filter(TimeLog.id == timelog_id).first() if not timelog: raise HTTPException(status_code=404, detail=\"TimeLog not found\") return timelog @router.get(\"/timelogs/\", response_model=List[TimeLog]) def read_timelogs(session: Session = Depends(get_session)): return session.query(TimeLog).all() @router.put(\"/timelogs/{timelog_id}\", response_model=TimeLog) def update_timelog(timelog_id: int, timelog: TimeLogCreate, session: Session = Depends(get_session)): db_timelog = session.query(TimeLog).filter(TimeLog.id == timelog_id).first() if not db_timelog: raise HTTPException(status_code=404, detail=\"TimeLog not found\") for var, value in vars(timelog).items(): setattr(db_timelog, var, value) if value else None session.commit() session.refresh(db_timelog) return db_timelog @router.delete(\"/timelogs/{timelog_id}\", response_model=dict) def delete_timelog(timelog_id: int, session: Session = Depends(get_session)): timelog = session.get(TimeLog, timelog_id) if not timelog: raise HTTPException(status_code=404, detail=\"TimeLog not found\") session.delete(timelog) session.commit() return {\"ok\": True} many-to-many, one-to-many router = APIRouter() @router.get(\"/categories/{category_id}/tasks\", response_model=List[Task]) def read_tasks_by_category(category_id: int, session: Session = Depends(get_session)): category = session.get(Category, category_id) if not category: raise HTTPException(status_code=404, detail=\"Category not found\") tasks = session.query(Task).join(TaskCategory).filter(TaskCategory.category_id == category_id).all() return tasks @router.get(\"/tasks/{task_id}/categories\", response_model=List[Category]) def read_categories_by_task(task_id: int, session: Session = Depends(get_session)): task = session.get(Task, task_id) if not task: raise HTTPException(status_code=404, detail=\"Task not found\") categories = session.query(Category).join(TaskCategory).filter(TaskCategory.task_id == task_id).all() return categories @router.get(\"/usersall/\", response_model=List[UserWithTaskNames]) def read_users_with_tasks(session: Session = Depends(get_session)): statement = select(User).options(joinedload(User.tasks)).distinct() result = session.execute(statement) users = result.scalars().unique().all() users_with_task_names = [] for user in users: user_data = { \"id\": user.id, \"username\": user.username, \"tasks\": [{\"title\": task.title} for task in user.tasks] } users_with_task_names.append(UserWithTaskNames(**user_data)) return users_with_task_names","title":"app/Routes.py"},{"location":"page4/#approutespy","text":"","title":"app/Routes.py"},{"location":"page4/#categories","text":"router = APIRouter() @router.get(\"/categories/{category_id}/tasks\", response_model=List[Task]) def read_tasks_by_category(category_id: int, session: Session = Depends(get_session)): category = session.get(Category, category_id) if not category: raise HTTPException(status_code=404, detail=\"Category not found\") tasks = session.query(Task).join(TaskCategory).filter(TaskCategory.category_id == category_id).all() return tasks @router.get(\"/tasks/{task_id}/categories\", response_model=List[Category]) def read_categories_by_task(task_id: int, session: Session = Depends(get_session)): task = session.get(Task, task_id) if not task: raise HTTPException(status_code=404, detail=\"Task not found\") categories = session.query(Category).join(TaskCategory).filter(TaskCategory.task_id == task_id).all() return categories @router.get(\"/usersall/\", response_model=List[UserWithTaskNames]) def read_users_with_tasks(session: Session = Depends(get_session)): statement = select(User).options(joinedload(User.tasks)).distinct() result = session.execute(statement) users = result.scalars().unique().all() users_with_task_names = [] for user in users: user_data = { \"id\": user.id, \"username\": user.username, \"tasks\": [{\"title\": task.title} for task in user.tasks] } users_with_task_names.append(UserWithTaskNames(**user_data)) return users_with_task_names","title":"categories"},{"location":"page4/#users","text":"router = APIRouter() @router.get(\"/users/\", response_model=List[UserResponse]) def read_users(session: Session = Depends(get_session)): users = session.execute(select(User)).scalars().all() return [UserResponse(id=user.id, username=user.username) for user in users] @router.get(\"/users/{user_id}\", response_model=User) def read_user(user_id: int, session: Session = Depends(get_session)): user = session.get(User, user_id) if user is None: raise HTTPException(status_code=404, detail=\"User not found\") return user @router.post(\"/users/\", response_model=int) def create_user(user: UserCreate, session: Session = Depends(get_session)): db_user = User(username=user.username) session.add(db_user) session.commit() session.refresh(db_user) return db_user.id @router.put(\"/users/{user_id}\") def update_user(user_id: int, user_update: UserUpdate, session: Session = Depends(get_session)): user = session.get(User, user_id) if not user: raise HTTPException(status_code=404, detail=\"User not found\") if user_update.username is not None: user.username = user_update.username session.commit() return {\"message\": \"User updated successfully\"} @router.delete(\"/users/{user_id}\") def delete_user(user_id: int, session: Session = Depends(get_session)): user = session.get(User, user_id) if not user: raise HTTPException(status_code=404, detail=\"User not found\") session.delete(user) session.commit() return {\"message\": \"User deleted successfully\"}","title":"users"},{"location":"page4/#tasks","text":"router = APIRouter() @router.post(\"/tasks/\", response_model=Task) def create_task(task: Task, session: Session = Depends(get_session)): db_task = Task.from_orm(task) session.add(db_task) session.commit() session.refresh(db_task) return db_task @router.get(\"/tasks/\", response_model=List[Task]) def read_tasks(session: Session = Depends(get_session)): tasks = session.execute(select(Task)).scalars().all() return tasks @router.get(\"/tasks/{task_id}\", response_model=Task) def read_task(task_id: int, session: Session = Depends(get_session)): task = session.get(Task, task_id) if not task: raise HTTPException(status_code=404, detail=\"Task not found\") return task @router.put(\"/tasks/{task_id}\", response_model=Task) def update_task(task_id: int, task_data: Task, session: Session = Depends(get_session)): db_task = session.get(Task, task_id) if not db_task: raise HTTPException(status_code=404, detail=\"Task not found\") update_data = task_data.dict(exclude_unset=True) for key, value in update_data.items(): setattr(db_task, key, value) session.add(db_task) session.commit() session.refresh(db_task) return db_task @router.delete(\"/tasks/{task_id}\", response_model=dict) def delete_task(task_id: int, session: Session = Depends(get_session)): task = session.get(Task, task_id) if not task: raise HTTPException(status_code=404, detail=\"Task not found\") timelogs = session.query(TimeLog).filter(TimeLog.task_id == task_id).all() for timelog in timelogs: session.delete(timelog) for task_category in task.task_categories: session.delete(task_category) session.delete(task) session.commit() return {\"ok\": True}","title":"tasks"},{"location":"page4/#taskscategories","text":"router = APIRouter() @router.post(\"/task_categories/\") def create_task_category(task_category_data: TaskCategoryCreate, session: Session = Depends(get_session)): task_category = TaskCategory(**task_category_data.dict()) session.add(task_category) session.commit() session.refresh(task_category) return task_category @router.get(\"/task_categories/\", response_model=List[TaskCategory]) def read_task_categories(session: Session = Depends(get_session)): task_categories = session.query(TaskCategory).all() return task_categories @router.get(\"/task_categories/{id}\", response_model=List[TaskCategory]) def read_task_category(task_id: int, category_id: int, session: Session = Depends(get_session)): statement = select(TaskCategory).where(TaskCategory.task_id == task_id, TaskCategory.category_id == category_id) results = session.exec(statement).all() if not results: raise HTTPException(status_code=404, detail=\"TaskCategory not found\") return results @router.put(\"/task_categories/{task_id}/{category_id}\", response_model=TaskCategoryUpdate) def update_task_category(task_id: int, category_id: int, task_category_update: TaskCategory, session: Session = Depends(get_session)): db_task_category = session.get(TaskCategory, {'task_id': task_id, 'category_id': category_id}) if not db_task_category: raise HTTPException(status_code=404, detail=\"TaskCategory not found\") db_task_category.additional_info = task_category_update.additional_info session.commit() return db_task_category","title":"tasksCategories"},{"location":"page4/#timelogs","text":"router = APIRouter() @router.post(\"/timelogs/\", response_model=TimeLog) def create_timelog(timelog: TimeLogCreate, session: Session = Depends(get_session)): task = session.get(Task, timelog.task_id) if not task: raise HTTPException(status_code=404, detail=f\"Task with id {timelog.task_id} not found\") db_timelog = TimeLog(**timelog.dict()) session.add(db_timelog) try: session.commit() except Exception as e: session.rollback() raise HTTPException(status_code=400, detail=str(e)) session.refresh(db_timelog) return db_timelog @router.get(\"/timelogs/{timelog_id}\", response_model=TimeLog) def read_timelog(timelog_id: int, session: Session = Depends(get_session)): timelog = session.query(TimeLog).filter(TimeLog.id == timelog_id).first() if not timelog: raise HTTPException(status_code=404, detail=\"TimeLog not found\") return timelog @router.get(\"/timelogs/\", response_model=List[TimeLog]) def read_timelogs(session: Session = Depends(get_session)): return session.query(TimeLog).all() @router.put(\"/timelogs/{timelog_id}\", response_model=TimeLog) def update_timelog(timelog_id: int, timelog: TimeLogCreate, session: Session = Depends(get_session)): db_timelog = session.query(TimeLog).filter(TimeLog.id == timelog_id).first() if not db_timelog: raise HTTPException(status_code=404, detail=\"TimeLog not found\") for var, value in vars(timelog).items(): setattr(db_timelog, var, value) if value else None session.commit() session.refresh(db_timelog) return db_timelog @router.delete(\"/timelogs/{timelog_id}\", response_model=dict) def delete_timelog(timelog_id: int, session: Session = Depends(get_session)): timelog = session.get(TimeLog, timelog_id) if not timelog: raise HTTPException(status_code=404, detail=\"TimeLog not found\") session.delete(timelog) session.commit() return {\"ok\": True}","title":"timelogs"},{"location":"page4/#many-to-many-one-to-many","text":"router = APIRouter() @router.get(\"/categories/{category_id}/tasks\", response_model=List[Task]) def read_tasks_by_category(category_id: int, session: Session = Depends(get_session)): category = session.get(Category, category_id) if not category: raise HTTPException(status_code=404, detail=\"Category not found\") tasks = session.query(Task).join(TaskCategory).filter(TaskCategory.category_id == category_id).all() return tasks @router.get(\"/tasks/{task_id}/categories\", response_model=List[Category]) def read_categories_by_task(task_id: int, session: Session = Depends(get_session)): task = session.get(Task, task_id) if not task: raise HTTPException(status_code=404, detail=\"Task not found\") categories = session.query(Category).join(TaskCategory).filter(TaskCategory.task_id == task_id).all() return categories @router.get(\"/usersall/\", response_model=List[UserWithTaskNames]) def read_users_with_tasks(session: Session = Depends(get_session)): statement = select(User).options(joinedload(User.tasks)).distinct() result = session.execute(statement) users = result.scalars().unique().all() users_with_task_names = [] for user in users: user_data = { \"id\": user.id, \"username\": user.username, \"tasks\": [{\"title\": task.title} for task in user.tasks] } users_with_task_names.append(UserWithTaskNames(**user_data)) return users_with_task_names","title":"many-to-many, one-to-many"},{"location":"page5/","text":"pydanticModels.py class UserUpdate(BaseModel): username: Optional[str] = None class UserCreate(BaseModel): username: str password: str class UserResponse(BaseModel): id: int username: str class TimeLogCreate(BaseModel): task_id: int time_spent_minutes: int date_logged: date class TaskCategoryCreate(BaseModel): task_id: int category_id: int additional_info: str class TaskCategoryUpdate(BaseModel): task_id: int category_id: int additional_info: str class Config: orm_mode = True class TaskName(BaseModel): title: str class UserWithTaskNames(BaseModel): id: int username: str tasks: List[TaskName] class UserInDB(UserCreate): hashed_password: str class UserOut(BaseModel): id: int username: str class Config: orm_mode = True class PasswordChange(BaseModel): old_password: str new_password: str","title":"pydanticModels.py"},{"location":"page5/#pydanticmodelspy","text":"class UserUpdate(BaseModel): username: Optional[str] = None class UserCreate(BaseModel): username: str password: str class UserResponse(BaseModel): id: int username: str class TimeLogCreate(BaseModel): task_id: int time_spent_minutes: int date_logged: date class TaskCategoryCreate(BaseModel): task_id: int category_id: int additional_info: str class TaskCategoryUpdate(BaseModel): task_id: int category_id: int additional_info: str class Config: orm_mode = True class TaskName(BaseModel): title: str class UserWithTaskNames(BaseModel): id: int username: str tasks: List[TaskName] class UserInDB(UserCreate): hashed_password: str class UserOut(BaseModel): id: int username: str class Config: orm_mode = True class PasswordChange(BaseModel): old_password: str new_password: str","title":"pydanticModels.py"},{"location":"page6/","text":"conn.py load_dotenv() db_url = os.getenv('DB_ADMIN') engine = create_engine(db_url, echo=True) def init_db(): SQLModel.metadata.create_all(engine) def get_session(): with Session(engine) as session: yield session","title":"conn.py"},{"location":"page6/#connpy","text":"load_dotenv() db_url = os.getenv('DB_ADMIN') engine = create_engine(db_url, echo=True) def init_db(): SQLModel.metadata.create_all(engine) def get_session(): with Session(engine) as session: yield session","title":"conn.py"}]}